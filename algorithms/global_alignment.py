import numpy as np
import sys
import re


np.set_printoptions(threshold=np.inf)
sequence_list = []
if len(sys.argv) > 1:
    file_name = sys.argv[1]


def main():
    s1, s2 = get_sequences(file_name)
    smatrix = create_matrix(s1, s2)

    seq1 = ''
    seq2 = ''
    j = len(s1)
    i = len(s2)
    max_score = smatrix[i,j][0]

    trace_paths(i, j, s1, s2, seq1, seq2, smatrix)

    # creates file containing the optimal score generated from the global alignment matrix
    f = open("optimal-score.out", "w+")
    f.write(str(max_score))
    f.close()

    # creates file containing the dynamic programming matrix generated by the Needleman-Wunsch algorithm
    f = open("dynamic-programming-matrix.out", "w+")
    f.write(print_matrix(smatrix))
    f.close()

    # creates file containing all possible optimal global alignments
    f = open("optimal-alignments.out", "w+")
    for pair in sequence_list:
        f.write(pair[0] + '\n' + pair[1] + '\n\n')
    f.close()


def server_results(s1, s2):
    valid_sequence = re.compile(r"^(A|T|C|G|U)*$")
    if re.fullmatch(valid_sequence, s1) and re.fullmatch(valid_sequence, s2):
        smatrix = create_matrix(s1, s2)
        seq1 = ''
        seq2 = ''
        j = len(s1)
        i = len(s2)
        max_score = smatrix[i,j][0]
        trace_paths(i, j, s1, s2, seq1, seq2, smatrix)
        optimal_alignments = ""
        for pair in sequence_list:
            optimal_alignments = optimal_alignments + pair[0] + "\n" + pair[1] + "\n\n"
        return [str(max_score), print_matrix(smatrix), optimal_alignments]
    return False


def get_sequences(file_name):  # retrieve s1 and s2 from given file (typically sequences.in)
    f = open(file_name)
    raw_list = f.read().split('>')
    f.close()
    raw_list.pop(0)
    sequence_list = []

    for ele in raw_list:
        sequence_list.append(ele.split('\n', 1)[1].replace('\n', ''))

    return sequence_list[0], sequence_list[1]


def print_matrix(smatrix):  # return the values of each cell in the matrix as a string
    i,j,z = smatrix.shape
    total_matrix = ''
    for row in range(j):
        row_string = ''
        for ele in smatrix[:,row]:
            row_string = row_string + str(ele[0]) + ' '
        row_string = row_string[:-1]
        total_matrix = total_matrix + row_string + '\n'
    return total_matrix


def create_matrix(s1,s2):  # convert given sequences to a matrix using the Needleman-Wunsch algorithm
    s1 = ' ' + s1
    s2 = ' ' + s2
    m = len(s1)
    n = len(s2)
    smatrix = np.array([[[-np.inf, []] for j in range(m)] for i in range(n)], dtype=object)

    for j in range(m):  # iterate through each cell of the matrix going row by row and starting at (0,0)
        for i in range(n):
            maxval = []
            if i == 0 and j == 0:  # set pos (0,0) to a score of 0
                smatrix[0,0][0] = 0
                continue

            if s1[j] == s2[i]:  # if there is a match, top-left cell +2 is added to list of possible maximum scores for the cell
                maxval.append([smatrix[i-1,j-1][0] + 2, (i-1,j-1)])

            elif i-1 >=0 and j-1 >= 0:  # if there is no match, top-left cell -1 is added to list of possible maximum scores for the cell
                maxval.append([smatrix[i-1,j-1][0] - 1, (i-1,j-1)])
                    
            if i-1 >=0 and j >= 0:  # if the cell directly to the left exists, left cell - 2 is added to list of possible maximum scores for the cell
                maxval.append([smatrix[i-1,j][0] - 2, (i-1,j)])

            if i >=0 and j-1 >= 0:  # if the cell directly above exists, above cell - 2 is added to list of possible maximum scores for the cell
                maxval.append([smatrix[i,j-1][0] - 2, (i,j-1)])

            temp_np = np.array(maxval)
            for ele in temp_np:  # append coordinates that result in max score of cell
                if int(ele[0]) == max(temp_np[:,0]):
                    smatrix[i,j][1].append(ele[1])

            smatrix[i,j][0] = max(temp_np[:,0])  # assign max score to cell in smatrix

    return smatrix


def trace_paths(i, j, s1, s2, seq1, seq2, smatrix):  # get all possible maximum scoring local alignments from matrix
    if not smatrix[i,j][1]:  # if the cell coordinates are (0,0), this is the end of the local alignment
        global sequence_list
        sequence_list.append([seq1, seq2])
        return

    for tup in smatrix[i,j][1]:   # for each possible cell this score in the cell came from, call trace_paths again
        if tup == (i-1,j-1):
            trace_paths(i-1, j-1, s1[:-1], s2[:-1], s1[-1] + seq1, s2[-1] + seq2, smatrix)
            
        if tup == (i-1,j):
            trace_paths(i-1, j, s1, s2[:-1], '-' + seq1, s2[-1] + seq2, smatrix)

        if tup == (i,j-1):
            trace_paths(i, j-1, s1[:-1], s2, s1[-1] + seq1, '-' + seq2, smatrix)


if __name__ == "__main__":
    main()